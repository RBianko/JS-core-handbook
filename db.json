[
    {
        "title": "ES6",
        "href": "es6",
        "features": [
            {
                "title": "Ключевые слова let и const",
                "href": "let_const",
                "src": ["1_1_let_const", "1_let_const"],
                "description": ["Появилось два новых способа объявить переменную - let и const, помимо устаревшего var. Если мы хотим переопределить переменную, объявленную с помощью var - у нас это получиться в любом месте скрипта. Переменную задекларированную с помощью let мы также можем спокойно переопределить, однако тут есть свои тонкости, о которых пойдёт речь дальше. Переменную, объявленную с помощью const мы не можем перезаписать - это константа, при попытке появится ошибка. Однако по сути, это распространяется только на примитивные значения(числа, строки, булевые значения и т.д.). Не примитивные значения мы не сможем перезаписать, в то же время, мы можем перезаписывать в них поля, например в массиве.",
                "У трёх способов объявления переменнух разные области видимости. У var она функциональная, игнорирующая другие скоупы. У let и const она блочная - по сути любой скоуп из фигурных скобок. При попытке обратиться к переменным появитя ошибка, т.к. в этой области видимости их не существует и они не видны только локально в своей области. Так же они не конфликтуют, если точно такие же переменные есть локально и глобально в скрипте. Переменные, объявленые с помощью ключевого слова var, подвержены такому механизму как хоистинг. Они, как function declaration и import, всплывают наверх, ограничиваясь только своей областью видимости, во время первого прочтения интерпретатором. Исходя из этого их можно вызывать в любом месте дкоумента и, в то же время, обращаться к ним даже до их объявления. Let и const на самом деле тоже всплывают, однако им не присваивается значения undefined, как для var. Поэтому при попытке обратиться к ним до их объявления будет ошибка."]
            },
            {
                "title": "Стрелочные функции",
                "href": "arrow",
                "src": ["2_arrow_func", "2_2_arrow_func"],
                "description": ["Стрелочные функции могут быть анонимными или создаваться через переменную. Они имеют более короткий синтаксис. В случае если тело функции возвращает значение в одну строку - фигурные скобки можно опустить. Если аргумент функции только один - круглые скобки можно опустить. Исходя из этого у них нет встроенного в каждую функцию псевдомассива arguments. При обращении к нему можно получить доступ к глобальному объекту", "Стрелочные функции особенные: у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции."]
            },
            {
                "title": "Деструктурирующее присваивание",
                "href": "#destruct",
                "src": ["3_distructing", "3_2_distructing"],
                "description": ["Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.", "Деструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны «идти»."]
            },
            {
                "title": "Оператор расширения и оставшиеся параметры (Spread, Rest)",
                "href": "rest",
                "src": ["4_spread_rest", "4_4_spread_rest"],
                "description": ["Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие (\"...\"): Переменная rest является массивом из оставшихся элементов. Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.", "Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора \"...\" («spread», троеточие):"]
            },
            {
                "title": "Шаблонные литералы",
                "href": "literal",
                "src": ["5_literal_templates"],
                "description": ["Шаблонные литералы заключены в обратные кавычки \" \" вместо двойных или одинарных. Они могут содержать подстановки, обозначаемые знаком доллара и фигурными скобками (${выражение}). Выражения в подстановках и текст между ними передаются в функцию. По умолчанию функция просто объединяет все части в строку. Если перед строкой есть выражение (здесь это tag), то шаблонная строка называется \"теговым шаблоном\". В этом случае, теговое выражение (обычно функция) вызывается с обработанным шаблонным литералом, который вы можете изменить перед выводом. Для экранирования обратной кавычки в шаблонных литералах указывается обратный слеш \\."]
            },
            {
                "title": "Методы for..in и for..off",
                "href": "for",
                "src": ["6_for-in_for-of"],
                "description": ["И for..in и for..of являются циклическими конструкциями, которые используются для перебора структур данных. Единственная разница в том, что они повторяют: for..in перебирает все перечисляемые ключи свойств объекта for..of перебирает значения итерируемого объекта. Примерами итерируемых объектов являются массивы, строки и списки узлов."]
            },
            {
                "title": "Динамические ключи объекта",
                "href": "dynamicKeyObj",
                "src": ["7_object-literal"],
                "description": ["В ES6 ключи можно назначать динамически, помещая выражение, определяющее имя, в квадратные скобки ([]) В ES5 нельзя было использовать переменные в качестве имён ключей, хотя ключ, имя которого задаётся переменной, можно было добавить после создания объекта. Например:"]
            },
            {
                "title": "Символы",
                "href": "symbols",
                "src": ["8_symbol"],
                "description": ["По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных. «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(): Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет."]
            },
            {
                "title": "Объект Map и WeakMap",
                "href": "map",
                "src": ["9_Map_WeakMap", "9_2_Map_WeakMap"],
                "description": ["Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа. Методы и свойства: new Map() – создаёт коллекцию. map.set(key, value) – записывает по ключу key значение value. map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует. map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false. map.delete(key) – удаляет элемент по ключу key. map.clear() – очищает коллекцию от всех элементов. map.size – возвращает текущее количество элементов.", "В основном, WeakMap используется в качестве дополнительного хранилища данных. Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то WeakMap – как раз то, что нужно. Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут."]
            },
            {
                "title": "Объект Set и WeakSet",
                "href": "set",
                "src": ["10_Set_WeakSet"],
                "description": ["Коллекция WeakSet ведёт себя похоже: Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения). Объект присутствует в множестве только до тех пор, пока доступен где-то ещё. Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой. Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте."]
            },
            {
                "title": "Объект Number",
                "href": "number",
                "src": ["11_Number"],
                "description": ["Числа типа number. Давайте глубже изучим, как с ними работать в JavaScript. isNaN(value) преобразует значение в число и проверяет является ли оно NaN. isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой (Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру)."]
            },
            {
                "title": "Объект Math",
                "href": "math",
                "src": ["12_Math"],
                "description": ["Метод Math.sign() возвращает знак числа, указывающий на то, является ли число отрицательным, положительным или нулём. функция Math.trunc() возвращает целую часть числа путём удаления всех дробных знаков. Метод Math.cbrt() возвращает кубический корень числа. Примеры:"]
            },
            {
                "title": "Объект Array",
                "href": "array",
                "src": ["13_Array"],
                "description": ["Массив (Array) в JavaScript является глобальным объектом, который используется для создания массивов; которые представляют собой высокоуровневые спископодобные объекты. Метод Array.of() - он принимает элементы и инициизирует ими массив. Еще один способ представляет функция Array.from(). find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true. findIndex похож на find, но возвращает индекс вместо значения. arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end."]
            },
            {
                "title": "Объект Object",
                "href": "object",
                "src": ["14_Object", "14_2_Object"],
                "description": ["Конструктор Object создаёт объект-обёртку для переданного значения. Если значением является null или undefined, создаёт и возвращает пустой объект, в противном случае возвращает объект такого типа, который соответствует переданному значению. Если значение уже является объектом, конструктор вернёт это значение. При вызове в не-конструктором контексте, Object ведёт себя идентично коду new Object(). Object.assign() - Создаёт новый объект путём копирования значений всех собственных перечислимых свойств из одного или более исходных объектов в целевой объект.", "Object.create() - Создаёт новый объект с указанными объектом прототипа и свойствами. Object.setPrototypeOf() - Устанавливает прототип (т.е. внутреннее свойство [[Prototype]])"]
            },
            {
                "title": "Объект String",
                "href": "string",
                "src": ["15_String"],
                "description": ["String - это встроенный в JS глобальный объект (доступ к которому можно получить везде), который принимает параметр и преобразует его в строку. Поскольку String является независимым объектом, а не методом, унаследованным от прототипа, то его можно использовать с объектами, у которых нет метода toString(). Одна особенность String(x) заключается в том, что он сначала вызывает toString(), а затем пытается использовать возвращаемое значение. Для поиска подстроки используйте indexOf или includes/startsWith/endsWith, когда надо только проверить, есть ли вхождение. str.repeat(n) — повторяет строку n раз."]
            },
            {
                "title": "Объект Reflect",
                "href": "reflect",
                "src": ["16_Reflection"],
                "description": ["Reflect - это встроенный объект, который предоставляет методы для перехватывания JavaScript операций. Эти методы аналогичны методам proxy handler'ов. Reflect - это не функциональный, а простой объект, он не является сконструированным. В отличие от большинства глобальных объектов, Reflect - это не конструктор. Вы не можете использовать его с оператором new или вызывать Reflect, как функцию. Все свойства и методы объекта Reflect являются статическими (так же, как и у объекта Math).Reflect.ownKeys() - Возвращает массив строк с именами собственных (не наследованных) свойств."]
            },
            {
                "title": "Классы",
                "href": "classes",
                "src": ["17_2_Class", "17_Class", "17_3_Class"],
                "description": ["Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар над существующим в JavaScript механизмом прототипного наследования. Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой и понятный способ создания объектов и организации наследования. Первый способ определения класса — class declaration (объявление класса). Для этого необходимо воспользоваться ключевым словом class и указать имя класса (в примере — Person).",
                    "Ключевое слово extends используется в объявлениях классов и выражениях классов для создания класса, дочернего относительно другого класса. Если в подклассе присутствует конструктор, он должен сначала вызвать super, прежде чем использовать this.",
                    "Метод constructor — специальный метод, необходимый для создания и инициализации объектов, созданных, с помощью класса. В классе может быть только один метод с именем constructor."]
            },
            {
                "title": "Промисы",
                "href": "promise",
                "src": ["18_Promise", "18_2_Promise", "18_3_Promise", "18_4_Promise"],
                "description": ["Интерфейс Promise (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова \"промис\") получить результат в некоторый момент в будущем.", "Promise.all(iterable) Ожидает исполнения всех промисов или отклонения любого из них. Возвращает промис, который исполнится после исполнения всех промисов в iterable. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.", "Promise.race(iterable) Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из .iterable.", "Promise.allSettled(iterable) Ожидает завершения всех полученных промисов (как исполнения так и отклонения). Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов."]
            },
            {
                "title": "Итераторы",
                "href": "iterators",
                "src": ["19_iterator", "19_1_iterator"],
                "description": [ "Объект является итератором, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая своё текущее положение внутри этой последовательности. В JavaScript итератор - это объект, который предоставляет метод next(), возвращающий следующий элемент последовательности. Этот метод возвращает объект с двумя свойствами: done и value. После создания, объект-итератор может быть явно использован, с помощью вызовов метода next().", "Чтобы быть итерируемым, объект обязан реализовать метод @@iterator, что означает, что он (или один из объектов выше по цепочке прототипов) обязан иметь свойство с именем Symbol.iterator:"]
            },
            {
                "title": "Генераторы",
                "href": "generators",
                "src": ["20_generator", "20_2_generator"],
                "description": [ "Генераторы предоставляют мощную альтернативу итераторам: они позволяют определить алгоритм перебора, написав единственную функцию, которая умеет поддерживать собственное состояние. Генераторы - это специальный тип функции, который работает как фабрика итераторов. Функция становится генератором, если содержит один или более yield операторов и использует function* синтаксис.", "Генераторы вычисляют результаты своих yield выражений по требованию, что позволяет им эффективно работать с последовательностями с высокой вычислительной сложностью, или даже с бесконечными последовательностями, как продемонстрировано выше. Метод next() также принимает значение, которое может использоваться для изменения внутреннего состояния генератора. Значение, переданное в next(), будет рассматриваться как результат последнего yield выражения, которое приостановило генератор."
                ]
            },
            {
                "title": "Объект Proxy",
                "href": "proxy",
                "src": ["21_Proxy"],
                "description": [
                    "Объект Proxy позволяет создать прокси для другого объекта, может перехватывать и переопределить основные операции для данного объекта. Прокси позволяют программисту определить поведение объекта при помощи JavaScript. Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие."
                ]
            },
            {
                "title": "Модули",
                "href": "modules",
                "src": ["22_modules_export", "22_modules_import"],
                "description": [ "Модуль – это просто файл. Один скрипт – это один модуль. Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого: export отмечает переменные и функции, которые должны быть доступны вне текущего модуля. import позволяет импортировать функциональность из других модулей. Каждый модуль имеет свою собственную область видимости.  Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.", "Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам. Это очень важно для понимания работы модулей."
                ]
            },
            {
                "title": "BigInt",
                "href": "bigInt",
                "src": ["22_1_BigInt"],
                "description": [
                    "BigInt это встроенный объект, который предоставляет способ представлять целые числа больше 253 - 1, наибольшего числа, которое JavaScript может надёжно представить с Number примитивом. Это максимальное значение можно получить, обратившись к Number.MAX_SAFE_INTEGER."
                ]
            }
        ]
    },
    {
        "title": "ES7",
        "href": "es7",
        "features": [
            {
                "title": "Array.prototype.includes()",
                "href": "arrayIncludes",
                "src": ["23_Array_includes"],
                "description": [
                    "Раньше приходилось использовать метод indexOf, для поиска элемента в массиве. Для массивов был добавлен метод, как для строк - includes. Он проверяет есть ли у данного массива искомый элемент и возвращает true или false, есть или нет, соответственно."
                ]
            },
            {
                "title": "Оператор возведения в степень",
                "href": "exp",
                "src": ["24_exponentiation"],
                "description": ["Метод Math.pow() возвращает основание, возведённое в степень показатель, то есть, значение выражения основание^показатель. Поскольку метод pow() является статическим методом объекта Math, вы всегда должны использовать его как Math.pow(), а не пытаться вызывать метод на созданном экземпляре объекта Math (поскольку объект Math не является конструктором)."]

            }

        ]
    },
    {
        "title": "ES8",
        "href": "es8",
        "features": [
            {
                "title": "Асинхронные функции async await",
                "href": "async",
                "src": ["25_async_await", "25_2_async_await"],
                "description": [
                    "Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования. У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически. Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.","Асинхронные функции приостанавливаются при каждом await выражении. Если выражение является промисом, то async-функция будет приостановлена до тех пор, пока промис не выполнится. Если же выражение не является промисом, то оно конвертируется в промис через Promise.resolve и потом завершается."]
            },
            {
                "title": "Object.values Object.entries",
                "href": "objValuesEntries",
                "src": ["26_Object_values_entries"],
                "description": [
                    "Object.entries() метод возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value], в том же порядке, что и в цикле for...in (разница в том, что for-in перечисляет свойства из цепочки прототипов). Порядок элементов в массиве который возвращается Object.entries() не зависит от того как объект объявлен. Метод  Object.values() возвращает массив значений перечисляемых свойств объекта в том же порядке что и цикл for...in. Разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов."
                ]
            },
            {
                "title": "Object.getOwnPropertyDescriptors()",
                "href": "getOwnPropertyDescriptors",
                "src": ["27_Object_getOwnPropertyDiscriptors"],
                "description": [
                    "Метод Object.getOwnPropertyDescriptors() возвращает все собственные дескрипторы свойств данного объекта. Этот метод позволяет изучить точное описание всех собственных свойств объекта. Свойство в JavaScript состоит из строкового имени или Symbol  и свойства дескриптора."
                ]

            },
            {
                "title": "Висящие запятые (Trailing commas)",
                "href": "commas",
                "src": ["28_trailing_commas"],
                "description": [
                    "ECMAScript 8 допускает висящие запятые в списке параметров функции, a так же можно использовать слева при использовании деструктурирующего присваивания. Висящие запятые не влияют на свойство length функции или их объект arguments. Если использовано больше одной висящей запятой, будут созданы \"дырки\". Массив с \"дырками\" называется разреженным (плотный массив не имеет \"дырок\"). При итерации массива при помощи, например, Array.prototype.forEach() или Array.prototype.map(), \"дырки\" будут пропущены."
                ]

            },
            {
                "title": "String.prototype.padEnd и padStart",
                "href": "padEndStart",
                "src": ["29_String_padEnd_padStart"],
                "description": [
                    "Метод padEnd() дополняет текущую строку с помощью заданной строки (в конечном счёте повторяя), так чтобы результирующая строка достигла заданной длины. Дополнение применяется в конце (справа) текущей строки. Метод padStart() заполняет текущую строку другой строкой (несколько раз, если нужно) так, что итоговая строка достигает заданной длины. Заполнение осуществляется в начале (слева) текущей строки."
                ]

            }

        ]
    },
    {
        "title": "ES9",
        "href": "es9",
        "features": [
            {
                "title": "Применение операторов spread и rest к объектам",
                "href": "objectRestSpread",
                "src": ["30_rest_spread_objects"],
                "description": [
                    "Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие \"...\". Переменная rest является массивом из оставшихся элементов.  Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании. Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который  получит «всё остальное», при помощи оператора \"...\" («spread»)"
                ]
            },
            {
                "title": "Асинхронные итераторы",
                "href": "asyncFor",
                "src": ["31_async_iterators"],
                "description": [
                    "Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно. Например, когда мы загружаем что-то по частям по сети. Асинхронные генераторы делают такой перебор ещё удобнее. Чтобы сделать объект итерируемым асинхронно: Используется Symbol.asyncIterator вместо Symbol.iterator. next() должен возвращать промис.Чтобы перебрать такой объект, используется цикл for await (let item of iterable)."
                ]

            },
            {
                "title": "Метод Promise.prototype.finally()",
                "href": "finally",
                "src": ["32_Promise_finally"],
                "description": [
                    "Метод finally() возвращает Promise. Когда промис был выполнен, вне зависимости успешно или с ошибкой, указанная функция будет выполнена. Это даёт возможность запустить один раз определённый участок кода, который должен выполниться вне зависимости от того, с каким результатом выполнился Promise. Это позволяет вам избавиться от дубликации кода в обработчиках then() и catch()."
                ]

            },
            {
                "title": "Улучшения регулярных выражений",
                "href": "enhancedRegExp",
                "src": ["33_enhanced_regExp"],
                "description": [
                    "Так выглядит lookahead (опережающая проверка) ?= (знак вопроса, равно): при опережающей проверке определяется строка, за которой следует определенная подстрока. Lookahead «смотрит» вперед и соответственно ставится в конце регулярного выражения. В данном примере мы ищем строку ‘Script’, перед которой стоит ‘Java’. ?! выполняет обратную операцию, проверяя, если за строкой не следует определенная подстрока lookbehind или ретроспективная проверка - это новая функция, которая использует ?<= (знак вопроса, знак меньше, равно) и «смотрит» назад для положительного утверждения. Кроме того, мы можем использовать ?<! (знак вопроса, знак меньше, восклицательный знак), чтобы найти отрицательное утверждение. Любой символ Юникода имеет набор свойств. Например, Script определяет семейство языков; ASCII - это логическое значение, которое true для символов ASCII, и так далее. Есть много других логических свойств, которые ты просто проверяешь добавляя их имя в фигурные скобки, включая Uppercase, Lowercase, White_Space, Alphabetic, Emoji и другие."
                ]

            }
        ]
    }
]
 